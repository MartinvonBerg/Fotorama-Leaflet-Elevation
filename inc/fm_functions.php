<?php
namespace mvbplugins\fotoramamulti;

require_once __DIR__ . '/extractMetadata.php';

// add the style for the grid to ALL headers!
// Generate the inline style for the CSS-Grid. Identical for all shortcodes!
add_action('wp_head', '\mvbplugins\fotoramamulti\fotorama_multi_styles', 100);
function fotorama_multi_styles( ) {
	$fotorama_elevation_options = get_option( 'fotorama_elevation_option_name' ); // Array of All Options
	$stylestring  = '<style id="fotorama_multi_inline_css" type="text/css">';
	$stylestring  .= '@media screen and (min-width: 480px) { .mfoto_grid { display: grid;';
	$stylestring  .= ' grid-template-columns: repeat(auto-fit, minmax('. $fotorama_elevation_options['min_width_css_grid_row_14'] .'px, 1fr)); grid-gap: 5px;} } </style>';  
	echo $stylestring;
}

// define the shutdown callback 
function action_shutdown( $array ) { 
    
	$fm_act_pis = \get_option('fm_plugins_checker');

	//if ( ('true' == $fm_act_pis['plugins_changed']) && ( \is_page() || \is_single()) ) { 
	if ( ( \is_page() || \is_single()) ) {
		$all = \mvbplugins\fotoramamulti\get_scripts_styles();
		$plugin_path = plugins_url() . '/';
		$plugin_name = plugin_basename( __FILE__ );
		$pos = \stripos( $plugin_name, '/' );
		$plugin_name = \substr($plugin_name, 0, $pos);
		$not_fm_scripts = array();
		$fm_scripts = array();
		
		// filter and sort the scripts loaded from all plugins and themes
		foreach ($all['scripts'] as $script) {
			$script = \str_replace( $plugin_path, '', $script);
			$is_fm_script = \stripos($script, $plugin_name);
			$suffix = \stripos( $script, '.js?' );
			if ( $suffix > 0 ) {
				$script = \substr($script, 0, $suffix+3);
			}
			$js = \basename($script, '.js');
			$min = \stripos( $js, 'min' );
			
			if ($min > 0) {
				$js = \str_replace('.min', '', $js);
			}

			if ( false === $is_fm_script ) {
				$not_fm_scripts[] = $js;
				$not_fm_scripts_complete[] = $script;
				$plugin = \str_replace( $plugin_path, '', $script);
				$pos = \stripos( $plugin, '/' );
				$plugin_check = \substr($plugin, 0, $pos);
				$plugin_conflict = \stripos( $plugin_check, 'leaflet' );
				if ( is_numeric($plugin_conflict) ) {
					$conflicting_plugin[] = $plugin_check . ' - detected by naming' ;
				}
				
			} else {
				$fm_scripts[] = $js;
			}
		}

		// check the scripts if there are double filenames
		foreach ($not_fm_scripts as $script) {
			if ( ! empty( $fm_scripts)  ) {
				$script_conflict = \in_array($script, $fm_scripts);
			} else {
				$script_conflict = false;
			}
			if ( $script_conflict ) {
				$plugin = \array_search($script, $all['scripts']);

				$search = $script . '.min.js';
				$matches = array_filter($not_fm_scripts_complete, function ($haystack) use ($search) {
					return(strpos($haystack, $search));
				});

				if ( \count($matches) == 0) {
					$search = $script . '.js';
					$matches = array_filter($not_fm_scripts_complete, function ($haystack) use ($search) {
						return(strpos($haystack, $search));
					});
				}
				// get the plugin of the conflicting script
				foreach ($matches as $match) {
					$plugin = \str_replace( $plugin_path, '', $match);
					$pos = \stripos( $plugin, '/' );
					$plugin_name = \substr($plugin, 0, $pos);
					$conflicting_script[] = $plugin_name . ' - ' . \str_replace($plugin_name, '', $match );
				}
				
			}
		}

		if ( empty( $conflicting_script ) && empty( $conflicting_plugin ) ) {
			$fm_act_pis['plugins_changed'] = 'false';
			$fm_act_pis['show_admin_message'] = 'false';
			$fm_act_pis['plugin_name'] = '';
		} else {
			$fm_act_pis['show_admin_message'] = 'true';
			$conflicting_script = \array_merge( (array)$conflicting_script, (array)$conflicting_plugin);
			$fm_act_pis['plugin_name'] = \maybe_serialize( $conflicting_script );
		}
		\update_option('fm_plugins_checker', $fm_act_pis);
	}
}
	
function fm_error_notice() {
	// error : red
	// is-dimissable : click away and forget.
	$fm_act_pis = \get_option('fm_plugins_checker');
	$fm_act_pis = \maybe_unserialize( $fm_act_pis['plugin_name'] );
    ?>
    <div class="notice notice-warning is-dismissible">
        <p><strong>Plugin Conflict detected: </strong><br></p>
		<p>The following Plugin(s) conflicts with Fotorama_multi:</p>
		<?php 
		foreach ($fm_act_pis as $conflict) {
			echo ( '<strong>' . $conflict . '</strong><br>');
		}
		?>
		<p>This message is generated by the Plugin "Fotorama_multi" after activation / deactivation of a plugin and usage of identical javascript files 
		on the same page or post. Deactivate Fotorama_multi or the above plugin(s), reload the relevant page or post and the admin page to remove this message. 
		</p>
    </div>
    <?php
}

function get_scripts_styles() {

    $result = [];
    $result['scripts'] = [];
    $result['styles'] = [];

    // Print all loaded Scripts
    global $wp_scripts;
	if ( 'array' == gettype( $wp_scripts) || 'object' == gettype( $wp_scripts) ) {
		foreach( $wp_scripts->queue as $script ) {
		$result['scripts'][] =  $wp_scripts->registered[$script]->src;
		}
	}

    // Print all loaded Styles (CSS)
    global $wp_styles;
	if ( 'array' == gettype( $wp_styles) || 'object' == gettype( $wp_styles) ) {
		foreach( $wp_styles->queue as $style ) {
		$result['styles'][] =  $wp_styles->registered[$style]->src;
		}
	}

    return $result;
}

/**
 * Get the upload URL/path in right way (works with SSL).
 *
 * @param string $param  "basedir" or "baseurl"
 * @param string $subfolder  subfolder to append to basedir or baseurl
 * @return string the base appended with subfolder
 */
function gpxview_get_upload_dir($param, $subfolder = '')
{
	$upload_dir = wp_get_upload_dir();
	$url = $upload_dir[$param];

	if ($param === 'baseurl' && is_ssl()) {
		$url = str_replace('http://', 'https://', $url);
	}

	return $url . $subfolder;
}

/**
 * Convert one part of GPS coordinates to float
 *
 * @param string $coordPart gpx coordinate-part, degree, minute or second
 * @return float GPS coordinates as number
 */
function gpxview_GPS2Num($coordPart)
{
	$parts = explode('/', $coordPart);

	if (count($parts) <= 0)
		return 0;

	if (count($parts) == 1)
		return $parts[0];

	return floatval($parts[0]) / floatval($parts[1]);
}

/**
 * calculate GPS-coordinates to float together with earth hemisphere
 *
 * @param array $exif-Coord One GPS-Coordinate taken from Exif in jpg-image in [degrees, minutes, seconds]
 * @param string $hemi earth hemisphere. If "W" or "S" it is the west or south half of earth
 * @return float|null gps-coordinate as number or null if $exif-Coord is not an array
 */
function gpxview_getGPS($exifCoord, $hemi)
{
	if ( ! is_array($exifCoord)) {
		return null;
	}

	$degrees = count($exifCoord) > 0 ? gpxview_GPS2Num($exifCoord[0]) : 0;
	$minutes = count($exifCoord) > 1 ? gpxview_GPS2Num($exifCoord[1]) : 0;
	$seconds = count($exifCoord) > 2 ? gpxview_GPS2Num($exifCoord[2]) : 0;

	$flip = ($hemi == 'W' or $hemi == 'S') ? -1 : 1;

	$gpsvalue = $flip * ($degrees + $minutes / 60 + $seconds / 3600);
	if (($gpsvalue <= 180.0) && ($gpsvalue >= -180.0) && is_numeric($gpsvalue)) {
		return $gpsvalue;
	} else {
		return null;
	}
}

/**
 * set custom fields 'lat' and 'lon' of the post
 *
 * @param int $pid the post-id
 * @param string $lat the GPS-coordinates lat as number
 * @param string $lon the GPS-coordinates lon as number
 * @return void
 */
function gpxview_setpostgps($pid, $lat, $lon)
{
	// es wurde vorab schon geprüft, dass die Werte $lat und $lon existieren. Stimmt nur für setzen aus Foto
	// Wenn Struktur GPS-XML abweicht, dann liefert simplexml leere Strings
	$oldlat = get_post_meta($pid,'lat');
	$oldlon = get_post_meta($pid,'lon');
	if ((count($oldlon)==0) && (count($oldlat)==0)) {
		update_post_meta($pid,'lat',$lat); 
		update_post_meta($pid,'lon',$lon);
		//echo ('Update Post-Meta lat und lon');
	} else { //if (strlen($oldlon[0]>=0) && strlen($oldlat[0]>=0)) {
		delete_post_meta($pid,'lat');
		delete_post_meta($pid,'lon');
		update_post_meta($pid,'lat',$lat); 
		update_post_meta($pid,'lon',$lon);
		//echo ('Update Post-Meta lat und lon');
	}
}

/**
 * get GPS-Longitude 'lon' and Latitude 'lat' from the Exif-Data in the image
 *
 * @param array $Exif the Exif-data read out from the image
 * @return array ($lon, $lat) the GPS-coordinates
 */
function gpxview_getLonLat($Exif)
{
	if (array_key_exists('GPS',$Exif) && ( null != $Exif["GPS"] ) && ( array_key_exists( 'GPSLongitude', $Exif["GPS"]) )) {
		$lon = gpxview_getGPS($Exif["GPS"]["GPSLongitude"], $Exif["GPS"]['GPSLongitudeRef']);
		$lat = gpxview_getGPS($Exif["GPS"]["GPSLatitude"], $Exif["GPS"]['GPSLatitudeRef']);
	} else {
		// "No GPS-Data available.."
		$lon = null;
		$lat = null;
	}
	
	return array($lon, $lat);
}

/**
 * Read-out single values from the Exif-Data, IPTC-Data in the file and -additionally- the WP-Media-Catalog-Database.
 * If found in the Catalog this information will be preferred. If title is not set or equal to the filename
 * it will be preset with 'notitle'.
 *
 * @param string $file the directory-path to the image file 
 * @param string $ext the file extension
 * @param int $wpid the wordpress-id of the image 
 * @return array array with collected information for the image
 */
function getEXIFData( $file, $ext, $wpid)
{
	// preset the title 
	$title = 'notitle';
	$ext = \strtolower( $ext );
	
	// read exif from file independent if image is in WP database TODO: move the jpeg part to a seperate function
	if ( ('.jpg' == $ext) || ('.jpeg' == $ext) ) {
		$data = getJpgMetadata( $file );

	} elseif ( '.webp' == $ext) {
		$data = getWebpMetadata( $file );
		if ($data['exposure_time'] > 0) {
			$data['exposure_time'] = '1/' . strval( 1 / $data['exposure_time'] );
		} else {
			$data['exposure_time'] = '--';
		}
		$data['datesort'] = '';
		$data['focal_length_in_35mm'] = '--';
		$data['iso'] = '--';
		$data['aperture'] = '--';
		$data['DateTimeOriginal'] = '';
	}

	// Post-Processing of $data for DateTimeOriginal
	if ( isset( $data["DateTimeOriginal"] ) ) { 
		$data['datesort'] = $data["DateTimeOriginal"];
		$date = wp_date( get_option( 'date_format' ), strtotime( $data['DateTimeOriginal'] ) );
		$data['DateTimeOriginal'] = $date;
	}

	// get additional data from the wp database, if it is there
	if ($wpid > 0) {
		
		// general jpeg and webp
		$wpmediadata = get_post( $wpid, 'ARRAY_A');
		$sort = get_post_meta( $wpid, 'gallery_sort', true) ?? '';
		$alt = get_post_meta( $wpid, '_wp_attachment_image_alt', true) ?? '' ;
		$meta = wp_get_attachment_metadata($wpid);

		// Sonderbehandlung wenn tags im jpg verfügbar sind
		$wptags = $meta["image_meta"]["keywords"]; 
		$tags = is_array($wptags) ? $wptags : '';
		$description = $wpmediadata["post_content"] ?? ''; // 'Beschreibung' in the Media-Catalog, means $description
		
		$title = $meta["image_meta"]["title"];
		$wptitle = $wpmediadata['post_title'];
		if ( $wptitle != basename($file, $ext) ) {
			$title = $wptitle;
		}
		$oldditle = $data['title'] ?? 'notitle';
		strlen($title) > 2 ? $data['title'] = $title : $data['title'] = $oldditle;

		//$description = $wpdescription != '' ? $wpdescription : $description;
		$caption = $meta["image_meta"]["caption"] ?? '';
		$wpcaption = $wpmediadata["post_excerpt"]; // 'Beschriftung' in the Media-Catalog, means caption
		$caption = $wpcaption != '' ? $wpcaption : $caption;

		// set the data fields 
		$data['sort'] = $sort;
		$data['alt'] = $alt;
		$data['caption'] = $caption;
		
		$tags != '' ? $data['keywords'] = $tags : '';
		$description != '' ? $data['descr'] = $description : '';
		 
		
	}
	
	return $data;
}

/**
 * check the availability of thumbnails
 *
 * @param string $pathtocheck 
 * @param string $thumbcheck the basename of the file with thumbnails to search for
 * @param string $ext the current extension ('jgp' or 'webp')
 * @return array with result values
 */
function checkThumbs ( string $thumbs, string $pathtocheck, string $thumbcheck, string $ext ) {
	$thumbinsubdir = true;
	
	if     ( is_file($pathtocheck . $thumbcheck) ) {
		$thumbs = $thumbcheck;
		}
	elseif ( is_file($pathtocheck . '-thumb' . $ext) ) {
		$thumbs = '-thumb' . $ext;
		}
	elseif ( is_file($pathtocheck . '_thumb' . $ext) ) {
		$thumbs = '_thumb' . $ext;
		}
	else {
		$thumbinsubdir = false;
	}

	return array ( $thumbinsubdir, $thumbs);
}